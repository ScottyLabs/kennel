# RFC 0002: Frontend

- **Status:** Accepted
- **Author(s):** @ap-1
- **Created:** 2026-02-24
- **Updated:** 2026-02-24

## Overview

This RFC defines the two frontend targets for Kennel: a documentation site built with Astro Starlight (`sites/docs/`) and a dashboard web application built with Svelte (`sites/web/`). Both live in the monorepo, use Bun as the JavaScript runtime, and are packaged as Nix derivations via `bun2nix`.

## Motivation

Kennel needs two distinct web frontends:

1. **Documentation** -- Kennel introduces new concepts (projects, services, deployments, environments) and a configuration format (`kennel.toml`). Without clear docs, onboarding projects to Kennel will be slow and error-prone.

1. **Dashboard** -- while the core pipeline runs autonomously via webhooks, developers need visibility into deployments, builds, and logs. They also need a way to register projects, trigger rebuilds, and manage deployments. A web UI is more accessible than a CLI for these tasks.

## Goals

- Define the technology stack for both frontend targets
- Establish the shared build tooling (Bun, `bun2nix`)
- Integrate both into the existing Nix build pipeline
- Cover authentication for the dashboard via Keycloak OIDC

## Non-Goals

- Backend API implementation (that's the `kennel-api` crate)
- User preference / A/B testing UI (post-MVP)
- End-user documentation for applications deployed by Kennel
- API client libraries or SDKs

## Detailed Design

### Shared Tooling

Both frontend targets use Bun as the JavaScript runtime and package manager. Dependencies are locked deterministically via `bun2nix` for Nix builds. This requires adding `bun2nix` as a flake input and `bun` to the devenv packages.

Both sites follow the same Nix derivation pattern:

```nix
site = b2n.mkDerivation {
  pname = "kennel-<site>";
  version = (builtins.fromJSON (builtins.readFile ./sites/<site>/package.json)).version;
  src = ./sites/<site>;

  bunDeps = b2n.fetchBunDeps {
    bunNix = ./sites/<site>/bun.nix;
  };

  buildPhase = ''
    bun run build
  '';

  installPhase = ''
    mkdir -p $out
    cp -r dist/* $out/
  '';
};
```

### Documentation Site (`sites/docs/`)

We're using [Starlight](https://starlight.astro.build/) (Astro). It provides search, Markdown/MDX support, sidebar navigation, and syntax highlighting out of the box. Astro's static site generation produces a lightweight, fast site.

Hosted at `docs.kennel.scottylabs.org`.

#### Topics

The documentation site should cover:

- **Getting Started** -- what Kennel is, how it fits into the ScottyLabs infrastructure, quickstart for adding a project
- **Project Configuration** -- `kennel.toml` reference, service types (service, static, image), branch configuration, environment mapping
- **Domain Scheme** -- how domains are assigned for single-service and multi-service projects, custom domains, wildcard certs
- **Secrets** -- OpenBao integration, per-environment secret paths, how secrets are injected
- **Build Pipeline** -- how Kennel builds Nix flakes, skip-if-unchanged logic, Cachix caching
- **Deployment Lifecycle** -- systemd units, static sites, port allocation, health checks, teardown, auto-expiry
- **PR Previews** -- how preview deployments work, ephemeral databases, auto-cleanup
- **Dashboard** -- how to use the web UI for monitoring deployments and builds
- **API Reference** -- REST API endpoints for programmatic access
- **Operations Guide** -- running Kennel, NixOS module configuration, startup reconciliation, troubleshooting

### Dashboard (`sites/web/`)

We're using Svelte with Vite, consistent with other ScottyLabs frontend projects. Svelte compiles to vanilla JS with minimal runtime overhead, and Vite provides instant HMR during development.

Hosted at `kennel.scottylabs.org`.

#### Type Safety

The Kennel backend exposes a REST API with an OpenAPI 3.1 spec generated by `utoipa`. The frontend uses `openapi-typescript` to generate TypeScript types from the spec, and `openapi-fetch` for a type-safe HTTP client. This creates a single source of truth flowing from Rust structs to TypeScript types.

#### Authentication

The dashboard authenticates via Keycloak OIDC, matching the existing ScottyLabs pattern used by OpenBao, Headplane, and other internal tools. The OIDC flow:

1. User visits `kennel.scottylabs.org`
1. Redirected to Keycloak login
1. On successful auth, Keycloak redirects back with an authorization code
1. Dashboard exchanges code for tokens via the backend
1. Backend sets a session cookie; subsequent requests are authenticated via cookie

The backend validates tokens against Keycloak's JWKS endpoint. Authorization is binary -- any authenticated ScottyLabs member can view and manage all projects.

#### Views

**Projects list** -- overview of all registered projects with their services and current deployment status across branches.

**Project detail** -- per-project view showing:

- All services and their types
- Deployment status per service per branch (active, building, failed)
- Recent builds with status and duration
- Links to preview deployments
- Secrets tab linking to the OpenBao UI filtered to the project's path

**Build detail** -- drill into a specific build showing:

- Per-service build results (success, skipped, failed)
- Build logs streamed in real-time via SSE
- Commit SHA, branch, and trigger source (webhook, manual)

**Register project** -- form to register a new project by providing the repository URL. Kennel clones the repo, reads `kennel.toml`, and sets up webhooks, DNS, and nginx.

**Manual actions** -- buttons for triggering a rebuild (per project or per service) and tearing down a branch deployment.

#### Real-time Updates

Build logs are streamed to the dashboard via Server-Sent Events (SSE). Deployment status changes are also pushed via SSE so the UI updates without polling. This uses the `GET /api/builds/:id/logs/:service` SSE endpoint.

#### Serving

In production, the Kennel backend serves the dashboard's static assets directly. The `kennel` binary embeds or references the built output so there's no separate web server for the dashboard. During development, `bun run dev` starts a Vite dev server with HMR that proxies API requests to the locally running Kennel backend.

### Deployment

Both sites are deployed by Kennel itself as static site services within the Kennel project. This serves as a dogfooding exercise. Before Kennel is operational, the sites can be served manually or via a simple nginx config.

## Alternatives Considered

### Documentation

- **Docusaurus** -- React-based, doesn't align with the Svelte ecosystem. No ability to share components.
- **VitePress** -- Vue-based, same ecosystem mismatch.
- **mdBook** -- Rust-native and simple, but lacks search, sidebar customization, and component embedding that Starlight provides.
- **Plain Markdown in the repo** -- No search, no navigation, poor reading experience.

### Dashboard

- **React** -- Larger ecosystem but more boilerplate, and the team prefers Svelte. Not consistent with other ScottyLabs projects.
- **Vue** -- Reasonable choice but not aligned with existing projects.
- **SvelteKit (SSR)** -- Adds SSR complexity. The dashboard is an authenticated SPA with no SEO requirements, so client-side rendering is simpler and sufficient.
- **No dashboard (CLI only)** -- Raises the barrier for developers who just want to check deployment status.

## Open Questions

None.

## Implementation Phases

1. Add `bun2nix` flake input and `bun` to devenv packages
1. Initialize Astro Starlight project in `sites/docs/`
1. Initialize Svelte + Vite project in `sites/web/`
1. Add Nix derivations for both sites
1. Write initial documentation pages covering `kennel.toml` and getting started
1. Set up OpenAPI type generation pipeline for the dashboard
1. Implement Keycloak OIDC authentication flow
1. Build project list, project detail, and build detail views
1. Add build log streaming via SSE
1. Add project registration and manual action controls
